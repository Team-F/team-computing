/*----------------------------------------------------------------------------------------------------------
Program Description:			Function for RobotC
Authors:									Seamus de Cleir and Dylan Crosbie
Date:											11/02/15
---------------------------------------------------------------------------------------------------------*/

//GLOBAL VARIABLES grid world dimensions
const int Xsize = 11;
const int Ysize = 9;

//GLOBAL ARRAY representation of grid world using a 2-Dimensional array
//100  = Off the table
//0  = Unexplored
//Numbered  = Clear Path
//80	 = Object
//90	 = Obstacle
//99 = Start

int map[Xsize][Ysize] =
 {{100,100,100,100,100,100,100,100,100},
  {100,0,0,0,99,0,0,0,100},
  {100,0,0,0,0,0,0,0,100},
  {100,0,0,0,0,0,0,0,100},
  {100,0,0,0,0,0,0,0,100},
  {100,0,0,0,0,0,0,0,100},
  {100,0,0,0,0,0,0,0,100},
  {100,0,0,0,0,0,0,0,100},
  {100,0,0,0,0,0,0,0,100},
  {100,0,0,0,0,0,0,0,100},
  {100,100,100,100,100,100,100,100,100}};



//lightThreshold function
int lightThreshold(int dark, int light){		//Calculates the light threshold
	//Declarations
	int t = 0;

	//Code Body
	t = (dark + light) / 2;
	return t;
}//End of lightThreshold


//rightTurn Function
void rightTurn(){
	nMotorEncoder[rightMotor] = 0;				//Sets the distance calculator to zero
	nMotorEncoder[leftMotor] = 0;

	while (nMotorEncoder[leftMotor] < 188 && nMotorEncoder[rightMotor] > -188){		//This while loop continues until the motor A has gone a -300 revolution
		motor[rightMotor] = -25;				//Moves motor A at -50%, turning the robot
		motor[leftMotor] = 25;

			}//End of while

	//stop for half second at end of movement
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
  wait1Msec(500);
}//End of rightTurn

//leftTurn Function
void leftTurn(){
	nMotorEncoder[rightMotor] = 0;				//Sets the distance calculator to zero
	nMotorEncoder[leftMotor] = 0;

	while (nMotorEncoder[rightMotor] < 188 && nMotorEncoder[leftMotor] > -188){		//This while loop continues until the motor A has gone a -300 revolution
		motor[rightMotor] = 25;				//Moves motor A at -50%, turning the robot
		motor[leftMotor] = -25;

		}//End of while

	//stop for half second at end of movement
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
  wait1Msec(500);
}//End of leftTurn


//moveForward
int moveForward(int blocks)
{
  int countsToTravel = ((23.7/13)*(360)*blocks)/2;

  nMotorEncoder[rightMotor] = 0;			//Resets both motors distance calculators
	nMotorEncoder[leftMotor] = 0;

	//encoder target for countsToTravel
  while (nMotorEncoder[rightMotor]<countsToTravel && nMotorEncoder[leftMotor]<countsToTravel){	//Moves the robot forward the target amount specified

		motor[leftMotor] = 50;				//Sets the power to a random number for both motors
		motor[rightMotor] = 50;
	}//End of while

	//stop for half second at end of movement
  	motor[rightMotor] = 0;
  	motor[leftMotor] = 0;
  	wait1Msec(300);

	if(SensorValue(lightSensor) < 30){
		nMotorEncoder[rightMotor] = 0;			//Resets both motors distance calculators
		nMotorEncoder[leftMotor] = 0;

		while (nMotorEncoder[rightMotor]> -(countsToTravel) && nMotorEncoder[leftMotor]> -(countsToTravel)){	//Moves the robot forward the target amount specified

		motor[leftMotor] = -50;				//Sets the power to a random number for both motors
		motor[rightMotor] =-50;
		}//End of while

		//stop for half second at end of movement
  	motor[rightMotor] = 0;
  	motor[leftMotor] = 0;
  	wait1Msec(500);
		return 1;
	}else{
	nMotorEncoder[rightMotor] = 0;			//Resets both motors distance calculators
	nMotorEncoder[leftMotor] = 0;

	while (nMotorEncoder[rightMotor]<countsToTravel && nMotorEncoder[leftMotor]<countsToTravel){	//Moves the robot forward the target amount specified

		motor[leftMotor] = 50;				//Sets the power to a random number for both motors
		motor[rightMotor] = 50;
	}//End of while

	//stop for half second at end of movement
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
  wait1Msec(500);
	return 0;
	}
}

//FUNCTION print wavefront map to NXT screen
void PrintWavefrontMap()
{
  int printLine = Ysize-1;
  for(int y = 0; y < Ysize; y++)
  {
    string printRow = "";
    for(int x=0; x < Xsize; x++)
    {
      if(map[x][y] == 99)
        printRow = printRow + "S ";
      else if(map[x][y] == 0)
        printRow = printRow + "U ";
      //else if(map[x][y] > 0 && map[x][y] < 80)
        //printRow = printRow + "C ";
      else if(map[x][y] == 90)
      	printRow = printRow + "O ";
      else if(map[x][y] == 80)
      	printRow = printRow + "G ";
      else if(map[x][y] == 100)
        printRow = printRow + "";
      else
        printRow = printRow + map[x][y];
    }
    nxtDisplayString(printLine, printRow);
    printLine--;
  }
}

//Navigate
void Navigate()
{
  //Robots Current Position
  int robotX, robotY;

  //Finds Robots current position
  for(int x=0; x < Xsize; x++)
  {
    for(int y=0; y < Ysize; y++)
    {
      if(map[x][y] == 99)
      {
        robotX = x;
        robotY = y;
      }
    }
  }

  //Picks next path
  int currentX = robotX;
  int currentY = robotY;
  int currentFacing = 0;
  int nextDirection = 0;
  int objectsFound = 0;
  int mine;
  int numbered = 0;
  int smallest;

  while(objectsFound != 2)
  {
    nextDirection = currentFacing;
    int nextX = 0;
    int nextY = 0;


    //If an object is sensed that the map records it as a 2(object)
		if(SensorValue(sonarSensor) < 30 && SensorValue(sonarSensor) > 10){
			if(currentFacing == 0){
				map[currentX][currentY-1] = 80;	//Sensed when facing South
			}
			else if(currentFacing == 1){
				map[currentX+1][currentY] = 80;	//Sensed when facing West
			}
			else if(currentFacing == 2){
				map[currentX][currentY+1] = 80;	//Sensed when facing North
			}
			else{
				map[currentX-1][currentY] = 80;	//Sensed when facing East
			}
			objectsFound++;
		}
		
		if(objectsFound == 2){
			return;
		}

    //Checks for free blocks
    if(map[currentX][currentY-1] == 0) //Is South space unchecked (0 = South)
    {
      nextX = currentX;
      nextY = currentY-1;
      nextDirection = 0;
    }
    else if(map[currentX+1][currentY] == 0)	//Is West space unchecked (1 = West)
    {
    	nextX = currentX+1;
      nextY = currentY;
      nextDirection = 1;
    }
    else if(map[currentX][currentY+1] == 0)	//Is North space unchecked (2 = North)
    {
    	nextX = currentX;
      nextY = currentY+1;
      nextDirection = 2;
    }
    else if(map[currentX-1][currentY] == 0)	//Is East space unchecked (3 = East)
    {
    	nextX = currentX-1;
      nextY = currentY;
      nextDirection = 3;
    }
    	else //No new spaces. Time to back trcak
    	{
	    	smallest = map[currentX][currentY-1];
	    	nextX = currentX;
		    nextY = currentY-1;
		    nextDirection = 0;
		      
	    	if(map[currentX+1][currentY] < smallest){
	    		smallest = map[currentX+1][currentY];
	    		nextX = currentX+1;
      		nextY = currentY;
      		nextDirection = 1;
	    	}
	    	if(map[currentX][currentY+1] < smallest){
	    		smallest = map[currentX][currentY+1];
	    		nextX = currentX;
      		nextY = currentY+1;
      		nextDirection = 2;
	    	}
	    	if(map[currentX-1][currentY] < smallest){
	    		smallest = map[currentX-1][currentY];
	    		nextX = currentX-1;
      		nextY = currentY;
      		nextDirection = 3;
      	}
    }

    //Finds the direction the robot should be facing
    while(currentFacing != nextDirection)
    {
      if (currentFacing < nextDirection)
      {
      	leftTurn();
        currentFacing++;

      }
      else if(currentFacing > nextDirection)
      {
      	rightTurn();
        currentFacing--;

      }//End of if
    }//End of while

    //Moves the Robot forward one block
    mine = moveForward(1);

    if(mine == 1){
			map[nextX][nextY] = 90;
		}else{
			//Updates current location
	    currentX = nextX;
	    currentY = nextY;
	    map[currentX][currentY] = numbered;
	    numbered++;
  	}

    PrintWavefrontMap();
    wait1Msec(500);

    }
}
