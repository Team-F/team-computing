/*----------------------------------------------------------------------------------------------------------
Program Description: 	Function for RobotC
Authors: 		Seamus de Cleir and Dylan Crosbie
Date: 			11/04/15
---------------------------------------------------------------------------------------------------------*/

#define EDGE 1000 //1000 = Edge of table
#define UNKNOWN 0 //0 = Unexplored
#define GOAL 800 //800 = Goal
#define ROBOT 888 //888 = Robot
#define MINE 900 //900 = Mine
#define START 999 //999 = Start

//----------------------------------------------------------------------------------------------------------------------//

/* This Array contains the map that shows up on the screen of the robot. It is constantly updated as the
	 Robot finds out more about its environment */

//Global 2D Array
const int Xsize = 11;
const int Ysize = 9;
int map[Xsize][Ysize] = {{1000,1000,1000,1000,1000,1000,1000,1000,1000},
			{1000,0,0,0,999,0,0,0,1000},
			{1000,0,0,0,0,0,0,0,1000},
			{1000,0,0,0,0,0,0,0,1000},
			{1000,0,0,0,0,0,0,0,1000},
			{1000,0,0,0,0,0,0,0,1000},
			{1000,0,0,0,0,0,0,0,1000},
			{1000,0,0,0,0,0,0,0,1000},
			{1000,0,0,0,0,0,0,0,1000},
			{1000,0,0,0,0,0,0,0,1000},
			{1000,1000,1000,1000,1000,1000,1000,1000,1000}};

//----------------------------------------------------------------------------------------------------------------------//

/* This Function simply preforms a 90 degree right turn */												
												
//rightTurn Function
void rightTurn(int turn){
	nMotorEncoder[rightMotor] = 0; //Sets the distance calculator to zero
	nMotorEncoder[leftMotor] = 0;
	
	while (nMotorEncoder[leftMotor] < turn && nMotorEncoder[rightMotor] > -(turn)){ //This while loop continues until the motor A has gone a -300 revolution
		motor[rightMotor] = -25; //Moves motor A at -50%, turning the robot
		motor[leftMotor] = 25;
	}//End of while
	
	//stop for half second at end of movement
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	wait1Msec(500);
	
}//End of rightTurn

//----------------------------------------------------------------------------------------------------------------------//

/* This Function simply preforms a 90 degree left turn */

//leftTurn Function
void leftTurn(int turn){
	
	nMotorEncoder[rightMotor] = 0; //Sets the distance calculator to zero
	nMotorEncoder[leftMotor] = 0;
	
	while (nMotorEncoder[rightMotor] < turn && nMotorEncoder[leftMotor] > -(turn)){ //This while loop continues until the motor A has gone a -300 revolution
		motor[rightMotor] = 25; //Moves motor A at -50%, turning the robot
		motor[leftMotor] = -25;
	}//End of while
	
	//stop for half second at end of movement
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	wait1Msec(500);
	
}//End of leftTurn

//----------------------------------------------------------------------------------------------------------------------//

/* Move just moves the robot forward without checking for mines */

//move
void move(int block){
	
	int count = 656*block;
	nMotorEncoder[rightMotor] = 0; //Resets both motors distance calculators
	nMotorEncoder[leftMotor] = 0;
	
	//encoder target for countsToTravel
	while (nMotorEncoder[rightMotor]<count&& nMotorEncoder[leftMotor]<count){ //Moves the robot forward the target amount specified
		motor[leftMotor] = 50; //Sets the power to a random number for both motors
		motor[rightMotor] = 50;
	}//End of while
	
	//stop for half second at end of movement
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;

}//End of move

//----------------------------------------------------------------------------------------------------------------------//

/* This Function is used to move the robot forward. It also checks squares infront for mines */

//moveForward
int moveForward(int blocks){
	
	int countsToTravel = 265*blocks;
	
	if(SensorValue(lightSensor) < 50){
		return 1;
	}else{
		nMotorEncoder[rightMotor] = 0; //Resets both motors distance calculators
		nMotorEncoder[leftMotor] = 0;
		
		while (nMotorEncoder[rightMotor]<countsToTravel && nMotorEncoder[leftMotor]<countsToTravel){ //Moves the robot forward the target amount specified
			motor[leftMotor] = 30; //Sets the power to a random number for both motors
			motor[rightMotor] = 30;
		}//End of while

		//stop for half second at end of movement
		motor[rightMotor] = 0;
		motor[leftMotor] = 0;
		//wait1Msec(200);
		return 0;
	}//End of if
	
}//End of moveForward

//----------------------------------------------------------------------------------------------------------------------//

/* This Function prints the array to the NXT screen */

//printWavefrontMap
void printWavefrontMap(){
	
	int printLine = Ysize-1;
	
	for(int y = 0; y < Ysize; y++){
		
		string printRow = "";
		
		for(int x=0; x < Xsize; x++){
			
			if(map[x][y] == START)
				printRow = printRow + "S ";
			else if(map[x][y] == UNKNOWN)
				printRow = printRow + "U ";
			else if(map[x][y] > UNKNOWN && map[x][y] < GOAL)
				printRow = printRow + "C ";
			else if(map[x][y] == MINE)
				printRow = printRow + "M ";
			else if(map[x][y] == GOAL)
				printRow = printRow + "G ";
			else if(map[x][y] == EDGE)
				printRow = printRow + "";
			else if(map[x][y] == ROBOT)
				printRow = printRow + "R ";
			else{
				printRow = printRow + map[x][y];
				}//End of if
				
			}//End of for
	
		nxtDisplayString(printLine, printRow);
		printLine--;
	}//End of for
	
}//End of printWavefrontMap

//----------------------------------------------------------------------------------------------------------------------//

/* This is how the robot decides what direction to move. It turns until the current 
	 direction matches the next direction */

//direction
int direction(int current, int next){
	
	//Finds the direction the robot should be facing
	while(current != next){
		
		if (current < next){
			leftTurn(183);
			current++;
		}else if(current > next){
			rightTurn(183);
			current--;
		}//End of if
		
	}//End of while
	
	return current;
	
}//End of direction

//----------------------------------------------------------------------------------------------------------------------//

/* If a sensed object is detected it is recorded onto the array using this function  */

//objectSensed
int objectSensed(int current, int objects, int x, int y){
	
	//If an object is sensed that the map records it as a 800(Goal)
	if(SensorValue(sonarSensor) < 30 && SensorValue(sonarSensor) > 10){
		
		if(current == 0){
			map[x][y-1] = GOAL; //Sensed when facing South
		}else if(current == 1){
			map[x+1][y] = GOAL; //Sensed when facing West
		}else if(current == 2){
			map[x][y+1] = GOAL; //Sensed when facing North
		}else{
			map[x-1][y] = GOAL; //Sensed when facing East
		}//End of if
		
		objects++;
		PlaySoundFile("Star-Wars-3318.rso");
		wait1Msec(1000);
	
	}//End of if
	
	return objects;
}//End of objectSensed

//----------------------------------------------------------------------------------------------------------------------//

/* Navigate is the main fuction that drives this robot. The main while loop is triggered to 
	 stop running when two objects are found, otherwise the robot will keep searching each
	 node on the array map until it can no longer turn into a node marked zero. If there
	 are no more zero marked nodes it moves to the smallest number. The robot always trys to
	 turn right */

//navigate
int navigate(){
	
	//Start Position
	int startX, startY;
	
	for(int x=0; x < Xsize; x++){ //Finds start position
		for(int y=0; y < Ysize; y++){
			
			if(map[x][y] == START){
				startX = x;
				startY = y;
			}//End of if
			
		}//End of for
		
	}//End of for
	
	//Declarations
	int currentX = startX;
	int currentY = startY;
	int currentFacing = 0;
	int nextDirection = 0;
	int objectsFound = 0;
	int objectNow = 0;
	int mine;
	int numbered = 1;
	int smallest;
	
	while(objectsFound != 2){
		
		nextDirection = currentFacing;
		int nextX = 0;
		int nextY = 0;
		
		//If an object is sensed that the map records it as a 900(Goal) & exits function
		objectsFound = objectSensed(currentFacing, objectsFound, currentX, currentY);
		
		if(objectsFound == 2){
			continue;
		}//End if
		
		switch(currentFacing){
			/*-----------------------CASE 0-----------------------*/
			case 0:
			//Checks for free blocks
			if(map[currentX-1][currentY] == UNKNOWN){ //Is Right space unchecked
				nextX = currentX-1;
				nextY = currentY;
				nextDirection = 3;
			}else if(map[currentX][currentY-1] == UNKNOWN){ //Is Striaght space unchecked (0 = South)
				nextX = currentX;
				nextY = currentY-1;
				nextDirection = 0;
			}else if(map[currentX+1][currentY] == UNKNOWN){ //Is North space unchecked (2 = )
				nextX = currentX+1;
				nextY = currentY;
				nextDirection = 1;
			}else if(map[currentX][currentY+1] == UNKNOWN){ //Is East space unchecked (3 = East)
				nextX = currentX;
				nextY = currentY+1;
				nextDirection = 2;
			}else{ //No new spaces. Time to back trcak
				smallest = map[currentX-1][currentY];
				nextX = currentX-1;
				nextY = currentY;
				nextDirection = 3;
				
				if(map[currentX][currentY-1] < smallest){
					smallest = map[currentX][currentY-1];
					nextX = currentX;
					nextY = currentY-1;
					nextDirection = 0;
				}//End of if
				
				if(map[currentX+1][currentY] < smallest){
					smallest = map[currentX+1][currentY];
					nextX = currentX+1;
					nextY = currentY;
					nextDirection = 1;
				}//End of if
				
				if(map[currentX][currentY+1] < smallest){
					smallest = map[currentX][currentY+1];
					nextX = currentX;
					nextY = currentY+1;
					nextDirection = 2;
				}//End of if
				
			}//End of if
			break;
			
			/*-----------------------CASE 1-----------------------*/
			case 1:
			//Checks for free blocks
			if(map[currentX][currentY-1] == UNKNOWN){ //Is North space unchecked (0 = South)
				nextX = currentX;
				nextY = currentY-1;
				nextDirection = 0;
			}else if(map[currentX+1][currentY] == UNKNOWN){ //Is West space unchecked (1 = West)
				nextX = currentX+1;
				nextY = currentY;
				nextDirection = 1;
			}else if(map[currentX][currentY+1] == UNKNOWN){ //Is North space unchecked (2 = North)
				nextX = currentX;
				nextY = currentY+1;
				nextDirection = 2;
			}else if(map[currentX-1][currentY] == UNKNOWN){ //Is East space unchecked (3 = East)
				nextX = currentX-1;
				nextY = currentY;
				nextDirection = 3;
			}else{ //No new spaces. Time to back trcak
				
				smallest = map[currentX][currentY-1];
				nextX = currentX;
				nextY = currentY-1;
				nextDirection = 0;
				
				if(map[currentX+1][currentY] < smallest){
					smallest = map[currentX+1][currentY];
					nextX = currentX+1;
					nextY = currentY;
					nextDirection = 1;
				}//End of if
				
				if(map[currentX][currentY+1] < smallest){
					smallest = map[currentX][currentY+1];
					nextX = currentX;
					nextY = currentY+1;
					nextDirection = 2;
				}//End of if
				
				if(map[currentX-1][currentY] < smallest){
					smallest = map[currentX-1][currentY];
					nextX = currentX-1;
					nextY = currentY;
					nextDirection = 3;
				}//End of if
				
			}//End of if
			break;
			
			/*-----------------------CASE 2-----------------------*/
			case 2:
			//Checks for free blocks
			if(map[currentX+1][currentY] == UNKNOWN){ //Is North space unchecked (0 = South)
				nextX = currentX+1;
				nextY = currentY;
				nextDirection = 1;
			}else if(map[currentX][currentY+1] == UNKNOWN){ //Is West space unchecked (1 = West)
				nextX = currentX;
				nextY = currentY+1;
				nextDirection = 2;
			}else if(map[currentX-1][currentY] == UNKNOWN){ //Is North space unchecked (2 = North)
				nextX = currentX-1;
				nextY = currentY;
				nextDirection = 3;
			}else if(map[currentX][currentY-1] == UNKNOWN){ //Is East space unchecked (3 = East)
				nextX = currentX;
				nextY = currentY-1;
				nextDirection = 0;
			}else{ //No new spaces. Time to back trcak
				smallest = map[currentX+1][currentY];
				nextX = currentX+1;
				nextY = currentY;
				nextDirection = 1;
				
				if(map[currentX][currentY+1] < smallest){
					smallest = map[currentX][currentY+1];
					nextX = currentX;
					nextY = currentY+1;
					nextDirection = 2;
				}//End of if
				
				if(map[currentX-1][currentY] < smallest){
					smallest = map[currentX-1][currentY];
					nextX = currentX-1;
					nextY = currentY;
					nextDirection = 3;
				}//End of if
				
				if(map[currentX][currentY-1] < smallest){
					smallest = map[currentX][currentY-1];
					nextX = currentX;
					nextY = currentY-1;
					nextDirection = 0;
				}//End of if
				
			}//End of if
			break;
			
			/*-----------------------CASE 3-----------------------*/
			case 3:
			//Checks for free blocks
			if(map[currentX][currentY+1] == UNKNOWN){ //Is North space unchecked (0 = South)
				nextX = currentX;
				nextY = currentY+1;
				nextDirection = 2;
			}else if(map[currentX-1][currentY] == UNKNOWN){ //Is West space unchecked (1 = West)
				nextX = currentX-1;
				nextY = currentY;
				nextDirection = 3;
			}else if(map[currentX][currentY-1] == UNKNOWN){ //Is North space unchecked (2 = North)
				nextX = currentX;
				nextY = currentY-1;
				nextDirection = 0;
			}else if(map[currentX+1][currentY] == UNKNOWN){ //Is East space unchecked (3 = East)
				nextX = currentX+1;
				nextY = currentY;
				nextDirection = 1;
			}else{ //No new spaces. Time to back trcak
			
				smallest = map[currentX][currentY+1];
				nextX = currentX;
				nextY = currentY+1;
				nextDirection = 2;
				
				if(map[currentX-1][currentY] < smallest){
					smallest = map[currentX-1][currentY];
					nextX = currentX-1;
					nextY = currentY;
					nextDirection = 3;
				}//End of if
				
				if(map[currentX][currentY-1] < smallest){
					smallest = map[currentX][currentY-1];
					nextX = currentX;
					nextY = currentY-1;
					nextDirection = 0;
				}//End of if
				
				if(map[currentX+1][currentY] < smallest){
					smallest = map[currentX+1][currentY];
					nextX = currentX+1;
					nextY = currentY;
					nextDirection = 1;
				}//End of if
				
			}//End of if
			break;
		
		}//End of switch
		
		//Finds the direction the robot should be facing
		currentFacing = direction(currentFacing, nextDirection);
		
		//If an object is sensed that the map records it as a 900(Goal)
		objectNow = objectSensed(currentFacing, objectNow, currentX, currentY);
		
		if(objectNow > 0){
			objectNow--;
			continue;
		}//End of if
		
		if(objectsFound == 2){
			continue;
		}//End of if
		
		//Moves the Robot forward one block
		mine = moveForward(1);
		
		if(mine == 1){
			map[nextX][nextY] = MINE;
			PlaySoundFile("dog_ruff.rso");
			wait1Msec(1000);
		}else{
			//Updates current location
			currentX = nextX;
			currentY = nextY;
			map[currentX][currentY] = numbered;
			numbered++;
		}//End of if
		
		printWavefrontMap();
		wait1Msec(500);
		
	}//End of while
	
	map[currentX][currentY] = 888;
	return currentFacing;
	
}//End of navigate

//----------------------------------------------------------------------------------------------------------------------

/* Once both objects are found this function works out the quickest way back to the starting point
	 using the wavefront algorithm. Each known node on the map is set to zero unless it is a mine.
	 Then by adding one to each adjacent node starting from the starting point a wavefront map is
	 formed. The robot then follows the smallest number back to the starting point */

//Wavefront Algorithm
int wavefront(int directionFacing){
	
	//Declarations
	int y, x;
	int xStart, yStart;
	int xRobot, yRobot;
	int xNext, yNext;
	int directionNext = 0;
	int lowest;
	
	//Clears the old map
	for(x=0;x<Xsize;x++){
		
		for(y=0;y<Ysize;y++){
			
			if(map[x][y] == UNKNOWN){
				map[x][y] = MINE;
			}else if(map[x][y] > UNKNOWN && map[x][y] < GOAL){
				map[x][y] = 0;
			}else if(map[x][y] == START){
				map[x][y] = 2;
			}//End of if
			
		}//End of for
		
	}//End of for
	
	//Finds the Robots Position
	for(x=0; x < Xsize; x++){ //Finds start position
		
		for(y=0; y < Ysize; y++){
			
			if(map[x][y] == ROBOT){
				xRobot = x;
				yRobot = y;
			}//End of if
			
		}//End of for
		
	}//End of for
	
	int wave = 2;
	int foundWave = 1;
	
	while(foundWave == 1){
		
		foundWave = 0;
		
		for(int y=0; y < Ysize; y++){
			
			for(int x=0; x < Xsize; x++){
		
				if(map[x][y] == wave){
					foundWave = true;
					xStart = x;
					yStart = y;
					
					if(xStart > 0) //This code checks the array bounds heading WEST
						if(map[xStart-1][yStart] == 0) //This code checks the WEST direction
							map[xStart-1][yStart] = wave + 1;
					
					if(xStart < (Xsize - 1)) //This code checks the array bounds heading EAST
						if(map[xStart+1][yStart] == 0)//This code checks the EAST direction
							map[xStart+1][yStart] = wave + 1;
					
					if(yStart > 0)//This code checks the array bounds heading SOUTH
						if(map[xStart][yStart-1] == 0) //This code checks the SOUTH direction
							map[xStart][yStart-1] = wave + 1;
					
					if(yStart < (Ysize - 1))//This code checks the array bounds heading NORTH
						if(map[xStart][yStart+1] == 0) //This code checks the NORTH direction
							map[xStart][yStart+1] = wave + 1;
				
				}//End of if
				
			}//End of for
			
		}//End of for
		
		wave++;
		
	}//End of while
	
	
	//Finds the Start Position
	for(x=0; x < Xsize; x++){ //Finds start position
		
		for(y=0; y < Ysize; y++){
		
			if(map[x][y] == 2){
				xStart = x;
				yStart = y;
			}//End of if
			
		}//End of for
		
	}//End of for
	
	while( map[xRobot][yRobot] != 2){
		
		lowest = map[xRobot][yRobot-1];
		xNext = xRobot;
		yNext = yRobot-1;
		directionNext = 0;
		
		if(map[xRobot+1][yRobot] < lowest){
			lowest = map[xRobot+1][yRobot];
			xNext = xRobot+1;
			yNext = yRobot;
			directionNext = 1;
		}//End of if
		
		if(map[xRobot][yRobot+1] < lowest){
			lowest = map[xRobot][yRobot+1];
			xNext = xRobot;
			yNext = yRobot+1;
			directionNext = 2;
		}//End of if
		
		if(map[xRobot-1][yRobot] < lowest){
			lowest = map[xRobot-1][yRobot];
			xNext = xRobot-1;
			yNext = yRobot;
			directionNext = 3;
		}//End of if
		
		xRobot = xNext;
		yRobot = yNext;
		
		//Finds the direction the robot should be facing
		directionFacing = direction(directionFacing, directionNext);
		printWavefrontMap();
		move(1);
		
	}//End of while
	
	return directionFacing;
	
}//End of wavefront

//----------------------------------------------------------------------------------------------------------------------

/* FinalBlock uses the Pythagorean theorem to figure out which block is closer and at what angle to travel */

//finalBlock
void finalBlock(int currentFace){
	
	//Declarations
	int Sx, Sy;
	int x, y;
	int closeX = 0;
	int closeY = 0;
	int diff = 0;
	int len1, len2;
	int diffY = 0;
	int diffHolder;
	int adj, opp, hypo;
	float angle;
	
	//Finds the Start Position
	for(x=0; x < Xsize; x++){ //Finds start position
		
		for(y=0; y < Ysize; y++){
			
			if(map[x][y] == 2){
				Sx = x;
				Sy = y;
			}//End of if
			
		}//End of for
		
	}//End of for
	
	//Find closed Goal
	for(x=0; x < Xsize; x++){
		
		for(y=0; y < Ysize; y++){
			
			if(map[x][y] == GOAL){
				
				diffY = y > Sy? (y-Sy):(Sy-y);
				len1 = (diffY + 1)*656.3;
				len2 = x * 656.3;
				hypo = len1^2 + len2^2;
				
				if(diff == 0){
				diffHolder = hypo;
				diff++;
				}//End of if
				
				if(hypo <= diffHolder){
					closeX = x;
					closeY = y;
				}//End of if
			
			}//End of if
			
		}//End of for
		
	}//End of for
	
	//Turn to South direction
	currentFace = direction(currentFace, 0);
	
	if(closeY == 1 && closeX > 4){
		//Turn to North direction
		currentFace = direction(currentFace, 2);
	}else if(closeY == 1 && closeX < 4){
		//Turn to South direction
		currentFace = direction(currentFace, 0);
	}else if(closeY == 4){
		//Turn to East direction
		currentFace = direction(currentFace, 1);
	}else{
		//Calculate Opposite and Adjacent
		diff = closeY > Sy? closeY-Sy:Sy-closeY;
		x = (diff+1) * 656.3;
		y = closeX * 656.3;
		adj = x > y? x:y;
		opp = x < y? x:y;
		map[6][6] = adj;
		map[6][7] = opp;
		map[1][1] = angle;
		angle = (atan2(adj, opp)*180)/3.14;
		
		if(closeY > 4){
			angle = angle + 90;
		}//End of if
	
		angle = angle*2.155555555555;
		
		//Complete turn is 388. 388 is 2.15555 times the size of 180
		leftTurn(angle);
		printWavefrontMap();
		
	}//End of if
	
	while(SensorValue(sonarSensor) > 30 || SensorValue(sonarSensor) < 10){
		move(1);
	}//End of while
	
}//End of finalBlock
