/*----------------------------------------------------------------------------------------------------------
Program Description: Function for RobotC
Authors: Seamus de Cleir and Dylan Crosbie
Date: 11/02/15
---------------------------------------------------------------------------------------------------------*/
#define EDGE 1000 //1000 = Edge of table
#define UNKNOWN 0 //0 = Unexplored
#define GOAL 800 //800 = Goal
#define ROBOT 888 //888 = Robot
#define MINE 900 //900 = Mine
#define START 999 //999 = Start
//Global 2D Array
const int Xsize = 11;
const int Ysize = 9;
int map[Xsize][Ysize] =
{{1000,1000,1000,1000,1000,1000,1000,1000,1000},
{1000,0,0,0,999,0,0,0,1000},
{1000,0,0,0,0,0,0,0,1000},
{1000,0,0,0,0,0,0,0,1000},
{1000,0,0,0,0,0,0,0,1000},
{1000,0,0,0,0,0,0,0,1000},
{1000,0,0,0,0,0,0,0,1000},
{1000,0,0,0,0,0,0,0,1000},
{1000,0,0,0,0,0,0,0,1000},
{1000,0,0,0,0,0,0,0,1000},
{1000,1000,1000,1000,1000,1000,1000,1000,1000}};
//lightThreshold function
int lightThreshold(int dark, int light){ //Calculates the light threshold
//Declarations
int t = 0;
//Code Body
t = (dark + light) / 2;
return t;
}//End of lightThreshold
//rightTurn Function
void rightTurn(int turn){
nMotorEncoder[rightMotor] = 0; //Sets the distance calculator to zero
nMotorEncoder[leftMotor] = 0;
while (nMotorEncoder[leftMotor] < turn && nMotorEncoder[rightMotor] > -(turn)){ //This while loop continues until the motor A has gone a -300 revolution
motor[rightMotor] = -25; //Moves motor A at -50%, turning the robot
motor[leftMotor] = 25;
}//End of while
//stop for half second at end of movement
motor[rightMotor] = 0;
motor[leftMotor] = 0;
wait1Msec(500);
}//End of rightTurn
//leftTurn Function
void leftTurn(int turn){
nMotorEncoder[rightMotor] = 0; //Sets the distance calculator to zero
nMotorEncoder[leftMotor] = 0;
while (nMotorEncoder[rightMotor] < turn && nMotorEncoder[leftMotor] > -(turn)){ //This while loop continues until the motor A has gone a -300 revolution
motor[rightMotor] = 25; //Moves motor A at -50%, turning the robot
motor[leftMotor] = -25;
}//End of while
//stop for half second at end of movement
motor[rightMotor] = 0;
motor[leftMotor] = 0;
wait1Msec(500);
}//End of leftTurn

//move
void move(int block)
{
int count = 656*block;
nMotorEncoder[rightMotor] = 0; //Resets both motors distance calculators
nMotorEncoder[leftMotor] = 0;
//encoder target for countsToTravel
while (nMotorEncoder[rightMotor]<count&& nMotorEncoder[leftMotor]<count){ //Moves the robot forward the target amount specified
motor[leftMotor] = 50; //Sets the power to a random number for both motors
motor[rightMotor] = 50;
}//End of while
//stop for half second at end of movement
motor[rightMotor] = 0;
motor[leftMotor] = 0;
//wait1Msec(250);
}

//moveForward
int moveForward(int blocks)
{
	int countsToTravel = 265;
	
	if(SensorValue(lightSensor) < 50){
	
	return 1;
}
else{
			nMotorEncoder[rightMotor] = 0; //Resets both motors distance calculators
			nMotorEncoder[leftMotor] = 0;
			while (nMotorEncoder[rightMotor]<countsToTravel && nMotorEncoder[leftMotor]<countsToTravel){ //Moves the robot forward the target amount specified
			motor[leftMotor] = 30; //Sets the power to a random number for both motors
			motor[rightMotor] = 30;
}//End of while

//stop for half second at end of movement
motor[rightMotor] = 0;
motor[leftMotor] = 0;
//wait1Msec(200);
return 0;
}
}


//printWavefrontMap
void printWavefrontMap()
{
int printLine = Ysize-1;
for(int y = 0; y < Ysize; y++)
{
string printRow = "";
for(int x=0; x < Xsize; x++)
{
if(map[x][y] == START)
printRow = printRow + "S ";
else if(map[x][y] == UNKNOWN)
printRow = printRow + "U ";
else if(map[x][y] > UNKNOWN && map[x][y] < GOAL)
printRow = printRow + "C ";
else if(map[x][y] == MINE)
printRow = printRow + "M ";
else if(map[x][y] == GOAL)
printRow = printRow + "G ";
else if(map[x][y] == EDGE)
printRow = printRow + "";
else if(map[x][y] == ROBOT)
printRow = printRow + "R ";
else
printRow = printRow + map[x][y];
}
nxtDisplayString(printLine, printRow);
printLine--;
}
}
//direction
int direction(int current, int next){
//Finds the direction the robot should be facing
while(current != next)
{
if (current < next)
{
leftTurn(183);
current++;
}
else if(current > next)
{
rightTurn(183);
current--;
}//End of if
}//End of while
return current;
}//End of direction
//objectSensed
int objectSensed(int current, int objects, int x, int y){
//If an object is sensed that the map records it as a 800(Goal)
if(SensorValue(sonarSensor) < 30 && SensorValue(sonarSensor) > 10){
if(current == 0){
map[x][y-1] = GOAL; //Sensed when facing South
}
else if(current == 1){
map[x+1][y] = GOAL; //Sensed when facing West
}
else if(current == 2){
map[x][y+1] = GOAL; //Sensed when facing North
}
else{
map[x-1][y] = GOAL; //Sensed when facing East
}
objects++;
PlaySoundFile("Star-Wars-3318.rso");
wait1Msec(1000);
}//End of if
return objects;
}//End of objectSensed
//navigate
int navigate()
{
//Start Position
int startX, startY;
for(int x=0; x < Xsize; x++) //Finds start position
{
for(int y=0; y < Ysize; y++)
{
if(map[x][y] == START)
{
startX = x;
startY = y;
}
}
}
//Declarations
int currentX = startX;
int currentY = startY;
int currentFacing = 0;
int nextDirection = 0;
int objectsFound = 0;
int objectNow = 0;
int mine;
int numbered = 1;
int smallest;
while(objectsFound != 2)
{
nextDirection = currentFacing;
int nextX = 0;
int nextY = 0;
//If an object is sensed that the map records it as a 900(Goal) & exits function
objectsFound = objectSensed(currentFacing, objectsFound, currentX, currentY);
if(objectsFound == 2){
continue;
}//End if
switch(currentFacing){
case 0:
//Checks for free blocks
if(map[currentX-1][currentY] == UNKNOWN) //Is Right space unchecked
{
nextX = currentX-1;
nextY = currentY;
nextDirection = 3;
}
else if(map[currentX][currentY-1] == UNKNOWN) //Is Striaght space unchecked (0 = South)
{
nextX = currentX;
nextY = currentY-1;
nextDirection = 0;
}
else if(map[currentX+1][currentY] == UNKNOWN) //Is North space unchecked (2 = )
{
nextX = currentX+1;
nextY = currentY;
nextDirection = 1;
}
else if(map[currentX][currentY+1] == UNKNOWN) //Is East space unchecked (3 = East)
{
nextX = currentX;
nextY = currentY+1;
nextDirection = 2;
}
else //No new spaces. Time to back trcak
{
smallest = map[currentX-1][currentY];
nextX = currentX-1;
nextY = currentY;
nextDirection = 3;
if(map[currentX][currentY-1] < smallest){
smallest = map[currentX][currentY-1];
nextX = currentX;
nextY = currentY-1;
nextDirection = 0;
}
if(map[currentX+1][currentY] < smallest){
smallest = map[currentX+1][currentY];
nextX = currentX+1;
nextY = currentY;
nextDirection = 1;
}
if(map[currentX][currentY+1] < smallest){
smallest = map[currentX][currentY+1];
nextX = currentX;
nextY = currentY+1;
nextDirection = 2;
}
}//End of if
break;
case 1:
//Checks for free blocks
if(map[currentX][currentY-1] == UNKNOWN) //Is North space unchecked (0 = South)
{
nextX = currentX;
nextY = currentY-1;
nextDirection = 0;
}
else if(map[currentX+1][currentY] == UNKNOWN) //Is West space unchecked (1 = West)
{
nextX = currentX+1;
nextY = currentY;
nextDirection = 1;
}
else if(map[currentX][currentY+1] == UNKNOWN) //Is North space unchecked (2 = North)
{
nextX = currentX;
nextY = currentY+1;
nextDirection = 2;
}
else if(map[currentX-1][currentY] == UNKNOWN) //Is East space unchecked (3 = East)
{
nextX = currentX-1;
nextY = currentY;
nextDirection = 3;
}
else //No new spaces. Time to back trcak
{
smallest = map[currentX][currentY-1];
nextX = currentX;
nextY = currentY-1;
nextDirection = 0;
if(map[currentX+1][currentY] < smallest){
smallest = map[currentX+1][currentY];
nextX = currentX+1;
nextY = currentY;
nextDirection = 1;
}
if(map[currentX][currentY+1] < smallest){
smallest = map[currentX][currentY+1];
nextX = currentX;
nextY = currentY+1;
nextDirection = 2;
}
if(map[currentX-1][currentY] < smallest){
smallest = map[currentX-1][currentY];
nextX = currentX-1;
nextY = currentY;
nextDirection = 3;
}
}//End of if
break;
case 2:
//Checks for free blocks
if(map[currentX+1][currentY] == UNKNOWN) //Is North space unchecked (0 = South)
{
nextX = currentX+1;
nextY = currentY;
nextDirection = 1;
}
else if(map[currentX][currentY+1] == UNKNOWN) //Is West space unchecked (1 = West)
{
nextX = currentX;
nextY = currentY+1;
nextDirection = 2;
}
else if(map[currentX-1][currentY] == UNKNOWN) //Is North space unchecked (2 = North)
{
nextX = currentX-1;
nextY = currentY;
nextDirection = 3;
}
else if(map[currentX][currentY-1] == UNKNOWN) //Is East space unchecked (3 = East)
{
nextX = currentX;
nextY = currentY-1;
nextDirection = 0;
}
else //No new spaces. Time to back trcak
{
smallest = map[currentX+1][currentY];
nextX = currentX+1;
nextY = currentY;
nextDirection = 1;
if(map[currentX][currentY+1] < smallest){
smallest = map[currentX][currentY+1];
nextX = currentX;
nextY = currentY+1;
nextDirection = 2;
}
if(map[currentX-1][currentY] < smallest){
smallest = map[currentX-1][currentY];
nextX = currentX-1;
nextY = currentY;
nextDirection = 3;
}
if(map[currentX][currentY-1] < smallest){
smallest = map[currentX][currentY-1];
nextX = currentX;
nextY = currentY-1;
nextDirection = 0;
}
}//End of if
break;
case 3:
//Checks for free blocks
if(map[currentX][currentY+1] == UNKNOWN) //Is North space unchecked (0 = South)
{
nextX = currentX;
nextY = currentY+1;
nextDirection = 2;
}
else if(map[currentX-1][currentY] == UNKNOWN) //Is West space unchecked (1 = West)
{
nextX = currentX-1;
nextY = currentY;
nextDirection = 3;
}
else if(map[currentX][currentY-1] == UNKNOWN) //Is North space unchecked (2 = North)
{
nextX = currentX;
nextY = currentY-1;
nextDirection = 0;
}
else if(map[currentX+1][currentY] == UNKNOWN) //Is East space unchecked (3 = East)
{
nextX = currentX+1;
nextY = currentY;
nextDirection = 1;
}
else //No new spaces. Time to back trcak
{
smallest = map[currentX][currentY+1];
nextX = currentX;
nextY = currentY+1;
nextDirection = 2;
if(map[currentX-1][currentY] < smallest){
smallest = map[currentX-1][currentY];
nextX = currentX-1;
nextY = currentY;
nextDirection = 3;
}
if(map[currentX][currentY-1] < smallest){
smallest = map[currentX][currentY-1];
nextX = currentX;
nextY = currentY-1;
nextDirection = 0;
}
if(map[currentX+1][currentY] < smallest){
smallest = map[currentX+1][currentY];
nextX = currentX+1;
nextY = currentY;
nextDirection = 1;
}
}//End of if
break;
}
//Finds the direction the robot should be facing
currentFacing = direction(currentFacing, nextDirection);
//If an object is sensed that the map records it as a 900(Goal)
objectNow = objectSensed(currentFacing, objectNow, currentX, currentY);
if(objectNow > 0){
objectNow--;
continue;
}
if(objectsFound == 2){
continue;
}
//Moves the Robot forward one block
mine = moveForward(1);
if(mine == 1){
map[nextX][nextY] = MINE;
PlaySoundFile("dog_ruff.rso");
wait1Msec(1000);
}else{
//Updates current location
currentX = nextX;
currentY = nextY;
map[currentX][currentY] = numbered;
numbered++;
}
printWavefrontMap();
wait1Msec(500);
}//End of while
map[currentX][currentY] = 888;
return currentFacing;
}//End of navigate
//Wavefront Algorithm
int wavefront(int directionFacing)
{
//Declarations
int y, x;
int xStart, yStart;
int xRobot, yRobot;
int xNext, yNext;
int directionNext = 0;
int lowest;
//Clears the old map
for(x=0;x<Xsize;x++)
{
for(y=0;y<Ysize;y++)
{
if(map[x][y] == UNKNOWN){
map[x][y] = MINE;
}else if(map[x][y] > UNKNOWN && map[x][y] < GOAL){
map[x][y] = 0;
}else if(map[x][y] == START){
map[x][y] = 2;
}
}
}
//Finds the Robots Position
for(x=0; x < Xsize; x++) //Finds start position
{
for(y=0; y < Ysize; y++)
{
if(map[x][y] == ROBOT)
{
xRobot = x;
yRobot = y;
}
}
}
int wave = 2;
int foundWave = 1;
while(foundWave == 1){
foundWave = 0;
for(int y=0; y < Ysize; y++)
{
for(int x=0; x < Xsize; x++)
{
if(map[x][y] == wave)
{
foundWave = true;
xStart = x;
yStart = y;
if(xStart > 0) //This code checks the array bounds heading WEST
if(map[xStart-1][yStart] == 0) //This code checks the WEST direction
map[xStart-1][yStart] = wave + 1;
if(xStart < (Xsize - 1)) //This code checks the array bounds heading EAST
if(map[xStart+1][yStart] == 0)//This code checks the EAST direction
map[xStart+1][yStart] = wave + 1;
if(yStart > 0)//This code checks the array bounds heading SOUTH
if(map[xStart][yStart-1] == 0) //This code checks the SOUTH direction
map[xStart][yStart-1] = wave + 1;
if(yStart < (Ysize - 1))//This code checks the array bounds heading NORTH
if(map[xStart][yStart+1] == 0) //This code checks the NORTH direction
map[xStart][yStart+1] = wave + 1;
}
}
}//End of for
wave++;
}//End of while
//Finds the Start Position
for(x=0; x < Xsize; x++) //Finds start position
{
for(y=0; y < Ysize; y++)
{
if(map[x][y] == 2)
{
xStart = x;
yStart = y;
}
}
}
while( map[xRobot][yRobot] != 2){
lowest = map[xRobot][yRobot-1];
xNext = xRobot;
yNext = yRobot-1;
directionNext = 0;
if(map[xRobot+1][yRobot] < lowest){
lowest = map[xRobot+1][yRobot];
xNext = xRobot+1;
yNext = yRobot;
directionNext = 1;
}
if(map[xRobot][yRobot+1] < lowest){
lowest = map[xRobot][yRobot+1];
xNext = xRobot;
yNext = yRobot+1;
directionNext = 2;
}
if(map[xRobot-1][yRobot] < lowest){
lowest = map[xRobot-1][yRobot];
xNext = xRobot-1;
yNext = yRobot;
directionNext = 3;
}
xRobot = xNext;
yRobot = yNext;
//Finds the direction the robot should be facing
directionFacing = direction(directionFacing, directionNext);
printWavefrontMap();
move(1);
}
return directionFacing;
}
//finalBlock
void finalBlock(int currentFace){
//Declarations
int Sx, Sy;
int x, y;
int closeX = 0;
int closeY = 0;
int diff = 0;
int len1, len2;
int diffY = 0;
int diffHolder;
int adj, opp, hypo;
float angle;
//Finds the Start Position
for(x=0; x < Xsize; x++) //Finds start position
{
for(y=0; y < Ysize; y++)
{
if(map[x][y] == 2)
{
Sx = x;
Sy = y;
}
}
}//End of for
//Find closed Goal
for(x=0; x < Xsize; x++)
{
for(y=0; y < Ysize; y++)
{
if(map[x][y] == GOAL)
{
diffY = y > Sy? (y-Sy):(Sy-y);
len1 = (diffY + 1)*656.3;
len2 = x * 656.3;
hypo = len1^2 + len2^2;
if(diff == 0){
diffHolder = hypo;
diff++;
}
if(hypo <= diffHolder){
closeX = x;
closeY = y;
}
}
}
}//End of for
//Turn to South direction
currentFace = direction(currentFace, 0);
if(closeY == 1 && closeX > 4){
//Turn to North direction
currentFace = direction(currentFace, 2);
}else if(closeY == 1 && closeX < 4){
//Turn to South direction
currentFace = direction(currentFace, 0);
}else if(closeY == 4){
//Turn to East direction
currentFace = direction(currentFace, 1);
}else{
//Calculate Opposite and Adjacent
diff = closeY > Sy? closeY-Sy:Sy-closeY;
x = (diff+1) * 656.3;
y = closeX * 656.3;
adj = x > y? x:y;
opp = x < y? x:y;
map[6][6] = adj;
map[6][7] = opp;
map[1][1] = angle;
angle = (atan2(adj, opp)*180)/3.14;
if(closeY > 4){
angle = angle + 90;
}
angle = angle*2.155555555555;
//Complete turn is 388. 388 is 2.15555 times the size of 180
leftTurn(angle);
printWavefrontMap();
}
while(SensorValue(sonarSensor) > 30 || SensorValue(sonarSensor) < 10){
move(1);
}
}//End of finalBlock
